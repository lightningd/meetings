<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>#lightning-dev log</title>
<style type="text/css">
/* For the .log.html */
pre { /*line-height: 125%;*/
      white-space: pre-wrap; }
body { background: #f0f0f0; }

body .tm  { color: #007020 }                      /* time */
body .nk  { color: #062873; font-weight: bold }   /* nick, regular */
body .nka { color: #007020; font-weight: bold }  /* action nick */
body .ac  { color: #00A000 }                      /* action line */
body .hi  { color: #4070a0 }                 /* hilights */
/* Things to make particular MeetBot commands stick out */
body .topic     { color: #007020; font-weight: bold }
body .topicline { color: #000080; font-weight: bold }
body .cmd       { color: #007020; font-weight: bold }
body .cmdline  { font-weight: bold }

</style>
</head>

<body>
<pre><a name="l-1"></a><span class="tm">20:07:22</span><span class="nk"> &lt;ariard&gt;</span> <span class="cmd">#startmeeting </span><span class="cmdline">lightning-dev</span>
<a name="l-2"></a><span class="tm">20:07:22</span><span class="nk"> &lt;lndev-bot&gt;</span> Meeting started Mon May 10 20:07:22 2021 UTC and is due to finish in 60 minutes.  The chair is ariard. Information about MeetBot at http://wiki.debian.org/MeetBot.
<a name="l-3"></a><span class="tm">20:07:22</span><span class="nk"> &lt;lndev-bot&gt;</span> Useful Commands: #action #agreed #help #info #idea #link #topic #startvote.
<a name="l-4"></a><span class="tm">20:07:22</span><span class="nk"> &lt;lndev-bot&gt;</span> The meeting name has been set to 'lightning_dev'
<a name="l-5"></a><span class="tm">20:07:29</span><span class="nk"> &lt;ariard&gt;</span> oh works at first try
<a name="l-6"></a><span class="tm">20:07:31</span><span class="nk"> &lt;rusty&gt;</span> I am liking "Canaux de foudre" though...
<a name="l-7"></a><span class="tm">20:07:55</span><span class="nk"> &lt;ariard&gt;</span> <span class="topic">#topic </span><span class="topicline">on-the-fly channel upgrade</span>
<a name="l-8"></a><span class="tm">20:08:18</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> you've the mic to explain #869, #868!
<a name="l-9"></a><span class="tm">20:08:20</span><span class="nk"> &lt;rusty&gt;</span> OK, I have an update draft... let me push it...
<a name="l-10"></a><span class="tm">20:08:27</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> we're probably going to use that one for a feature, "canaux de foudre" looks badass
<a name="l-11"></a><span class="tm">20:09:22</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> :)
<a name="l-12"></a><span class="tm">20:09:40</span><span class="nk"> &lt;cdecker&gt;</span> Excellent choice of message names ^^
<a name="l-13"></a><span class="tm">20:10:01</span><span class="nk"> &lt;rusty&gt;</span> OK, so I was looking at channel upgrade.  We have wanted this for a while, but I really did want it for simplified update protocol.
<a name="l-14"></a><span class="tm">20:10:52</span><span class="nk"> &lt;rusty&gt;</span> It's easiest if you can assert that the new method/format applies canonically from a given commit number.  Turns out that fits pretty well with reconnection, where we explicitly send the numbers.
<a name="l-15"></a><span class="tm">20:11:01</span><span class="nk"> &lt;roasbeef&gt;</span> saw that, was interesting we went w/ pretty different approaches (independent of the scope of simplified updates, not sure how much value vs effort that brings)
<a name="l-16"></a><span class="tm">20:11:23</span><span class="nk"> &lt;roasbeef&gt;</span> the main diff is that what I've been working on in the background moves to making everything explicit w.r.t channel funding, as soon there may not be a "default/preferred" chan type
<a name="l-17"></a><span class="tm">20:11:58</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, taproot will be a big one too.
<a name="l-18"></a><span class="tm">20:12:21</span><span class="nk"> &lt;roasbeef&gt;</span> also what I've been tinkering on is a bit more general, as it makes room to let you update things like the dust limit or the # of max HTLCs on the fly, while the channle is being used within teh same connection context
<a name="l-19"></a><span class="tm">20:12:37</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> this protocol is basically "one side proposes update, the other says what updates are OK".
<a name="l-20"></a><span class="tm">20:12:39</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> are you covering channel policy update, like open/accept scopes?
<a name="l-21"></a><span class="tm">20:12:51</span><span class="nk"> &lt;roasbeef&gt;</span> been bogged down by the non-LN parts of my job, so I've had it paused for the past few weeks
<a name="l-22"></a><span class="tm">20:13:16</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> not sure what that means?
<a name="l-23"></a><span class="tm">20:13:20</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> IIUC updating things like dust_limit or max_accepted_htlcs would also be easy with rusty's proposal, or am I missing something?
<a name="l-24"></a><span class="tm">20:13:39</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> but you'd need to re-initiate the connection right?
<a name="l-25"></a><span class="tm">20:13:42</span><span class="nk"> &lt;t-bast&gt;</span> It sounds like once we're in quiescence, we can upgrade pretty much whatever we want
<a name="l-26"></a><span class="tm">20:13:46</span><span class="nk"> &lt;roasbeef&gt;</span> it also doesn't make things explicit
<a name="l-27"></a><span class="tm">20:14:09</span><span class="nk"> &lt;roasbeef&gt;</span> like w/ mine, we add a chan_type to the open/accept messages, so we avoid the weird issues we ran into when we make certain feature bits required, and we had to downgrade our bits to maintain connections w/ eclair nodes, etc
<a name="l-28"></a><span class="tm">20:14:12</span><span class="nk"> &lt;t-bast&gt;</span> oh got it, but I don't think we'd need the channel_reestablish to trigger updating channel parameters once we're in quiescence, right rusty?
<a name="l-29"></a><span class="tm">20:14:43</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> well things like dust_limit, htlc_min_msat
<a name="l-30"></a><span class="tm">20:14:45</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span>  it's far easier, since it automatically works for lost messages though.
<a name="l-31"></a><span class="tm">20:14:49</span><span class="nk"> &lt;roasbeef&gt;</span> at a high level I've been tinkering with: new shtudown liek message to propose a commitment update, new update_fee like message to commit the proposal by one or both nodes, works w/ the existing retransmission stuff as it's just another log update
<a name="l-32"></a><span class="tm">20:14:51</span><span class="nk"> &lt;cdecker&gt;</span> Yes, the reconnect commit is separate from the quiescence
<a name="l-33"></a><span class="tm">20:15:19</span><span class="nk"> &lt;roasbeef&gt;</span> not following where quiescence comes in?
<a name="l-34"></a><span class="tm">20:15:23</span><span class="nk"> &lt;rusty&gt;</span> Frankly, changing other things is far far easier with simplified commitment update.  You're *always* quiescent at the start of your turn, and the state is the same on both sides.
<a name="l-35"></a><span class="tm">20:15:33</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> so your proposal is kind of a two-phase commit with new messages?
<a name="l-36"></a><span class="tm">20:15:57</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> yes, w/ the initaitor doing the commit, with a fast path where if only the responder wants to change then you can do it more quickly
<a name="l-37"></a><span class="tm">20:16:13</span><span class="nk"> &lt;roasbeef&gt;</span> it also leaves room for backing out, since only the initator commits the actual confi change
<a name="l-38"></a><span class="tm">20:16:19</span><span class="nk"> &lt;roasbeef&gt;</span> it works kinda like the way raft does config updates
<a name="l-39"></a><span class="tm">20:16:41</span><span class="nk"> &lt;roasbeef&gt;</span> backing out as in, I disagree w/ your fancy commitment type or w/e, so we don't need to run into like an invalid sig and destroy the channel in that case or w/e
<a name="l-40"></a><span class="tm">20:16:56</span><span class="nk"> &lt;t-bast&gt;</span> it's true that the high-level feature we want to get (updating channel things) has a very large design space
<a name="l-41"></a><span class="tm">20:17:43</span><span class="nk"> &lt;roasbeef&gt;</span> indeed, I had a goal to go w/ something more general, and there're a lot of hard coded params rn that you can't ever change once the chan is open, so had eyes set on a two birds w/ one stone kinda thing
<a name="l-42"></a><span class="tm">20:17:48</span><span class="nk"> &lt;niftynei&gt;</span> where does splice fit into the list of "channel update parameters"
<a name="l-43"></a><span class="tm">20:17:59</span><span class="nk"> &lt;rusty&gt;</span> I'm determined to pursue simplified commitment protocol, since I don't believe we will ever get all the synchronization bugs out of all the implementations :(  It's been five years and we're still finding them.  Adding more complexity is not a win.
<a name="l-44"></a><span class="tm">20:18:01</span><span class="nk"> &lt;roasbeef&gt;</span> the propose messages are just a signed tlv (signed so the initaitor can do retransmission, etc)
<a name="l-45"></a><span class="tm">20:18:01</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> simplified commitment update is the change to the channel state machine, right? Where we have turns instead of the current message flow?
<a name="l-46"></a><span class="tm">20:18:21</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> kind of.  It's just a subset of the current state machine.
<a name="l-47"></a><span class="tm">20:18:39</span><span class="nk"> &lt;roasbeef&gt;</span> if ppl implement the simplified stuff or not, again we'd need to make sure we have explicit funding, as it makes diff tradeoffs
<a name="l-48"></a><span class="tm">20:18:58</span><span class="nk"> &lt;roasbeef&gt;</span> we fixed a recent issue on our state machine, likely the last (fingers crossed lol)?
<a name="l-49"></a><span class="tm">20:19:05 </span><span class="nka">* BlueMatt</span> <span class="ac">admits he likes going with quiescence/turns on new changes, but is dubious of the value of doing turns for existing stuff.</span>
<a name="l-50"></a><span class="tm">20:19:22</span><span class="nk"> &lt;roasbeef&gt;</span> but I guess is it a bigger hill to climb to introduce something brand new or just better understand/formalize/spec the existing one
<a name="l-51"></a><span class="tm">20:19:28</span><span class="nk"> &lt;BlueMatt&gt;</span> does anyone else have fuzzing on their state machine to catch the inconsistent-state bugs?
<a name="l-52"></a><span class="tm">20:19:33</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> it makes splicing, and changing other channel parameters much easier.
<a name="l-53"></a><span class="tm">20:19:39</span><span class="nk"> &lt;roasbeef&gt;</span> yeh we've been using one to find our recent issues BlueMatt
<a name="l-54"></a><span class="tm">20:20:11</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> at the cost of x-put, and also the effort to switch everything over (and the unknowns that lie there) to the new method?
<a name="l-55"></a><span class="tm">20:20:41</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> that's why I'm implementing it, so I have a concrete idea of what's involved.
<a name="l-56"></a><span class="tm">20:21:12</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">rusty:</span> right, we've hashed this out on the ml, I dont really think I have anything to add to that convo beyond what I'd said before - that quiescence relies on a lot of the same code as shutdown anyway, whereas simplified commitment adds new logic around queues, so I'd think the first is easier, but curious to see your implementation.
<a name="l-57"></a><span class="tm">20:21:26</span><span class="nk"> &lt;roasbeef&gt;</span> mhmm, but then there may be a scenario where ppl add it, but don't make it the default, which motivates explicit funding (so no more feature bit implicit negotiation)
<a name="l-58"></a><span class="tm">20:21:33</span><span class="nk"> &lt;rusty&gt;</span> BlueMatt:quiescence also needs queues :)
<a name="l-59"></a><span class="tm">20:21:43</span><span class="nk"> &lt;niftynei&gt;</span> what is explicit funding?
<a name="l-60"></a><span class="tm">20:21:58</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> so my open chan message just adds a new tlv that says the type of channel I'm opening
<a name="l-61"></a><span class="tm">20:22:13</span><span class="nk"> &lt;roasbeef&gt;</span> rn we expect a certain type based on feature bits, which doesn't work when you have "non-default" commitment/funding types
<a name="l-62"></a><span class="tm">20:22:22</span><span class="nk"> &lt;ariard&gt;</span> ah, typed funding sounds a good name
<a name="l-63"></a><span class="tm">20:22:37</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">rusty:</span> true, but for fewer things - I *think* it adds fewer states, but I may be wrong.
<a name="l-64"></a><span class="tm">20:22:45</span><span class="nk"> &lt;roasbeef&gt;</span> like we had an issue when we made static key required: older nodes didn't udnerstand it, so we couldn't establish our older connections w/ say eclair nodes, and had to _downgrade_ those feature bits, then reject those funding attempts we didn't like
<a name="l-65"></a><span class="tm">20:22:46</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, I wrestled with the same. I have been calling them channel features, which is overloaded unf.  Types is beter.
<a name="l-66"></a><span class="tm">20:22:55</span><span class="nk"> &lt;roasbeef&gt;</span> vs being able to signal what you understand, then explicitly tell the other side which one yuo're trying to use
<a name="l-67"></a><span class="tm">20:23:22</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, definitely better for diags when things go wrong, too.
<a name="l-68"></a><span class="tm">20:23:31</span><span class="nk"> &lt;roasbeef&gt;</span> so there's another thing here about the ability to not really flip chan related featire bits to required
<a name="l-69"></a><span class="tm">20:23:32</span><span class="nk"> &lt;t-bast&gt;</span> yep that would be quite useful
<a name="l-70"></a><span class="tm">20:23:44</span><span class="nk"> &lt;roasbeef&gt;</span> as then you can't maintain older connections w/ those you have legacy chans w/, w/o unsetting those bits
<a name="l-71"></a><span class="tm">20:24:07</span><span class="nk"> &lt;roasbeef&gt;</span> you're basically forced to downgrade to the lowest common known chan vs being able to keep that connection then only accepting requests to fund your preferred chans
<a name="l-72"></a><span class="tm">20:24:17</span><span class="nk"> &lt;niftynei&gt;</span> oh i see. interesting
<a name="l-73"></a><span class="tm">20:24:21</span><span class="nk"> &lt;rusty&gt;</span> Yes, channel bits in open/accept FTW?
<a name="l-74"></a><span class="tm">20:24:30</span><span class="nk"> &lt;roasbeef&gt;</span> not bits, just an explicit type
<a name="l-75"></a><span class="tm">20:24:31</span><span class="nk"> &lt;rusty&gt;</span> Though ideally upgrade will also help transition.
<a name="l-76"></a><span class="tm">20:24:36</span><span class="nk"> &lt;roasbeef&gt;</span> since you need to pick one
<a name="l-77"></a><span class="tm">20:24:52</span><span class="nk"> &lt;niftynei&gt;</span> picking the type scope seems... challenging
<a name="l-78"></a><span class="tm">20:25:00</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> except simplified commitment protocol is an orthogonal option unfortunately.
<a name="l-79"></a><span class="tm">20:25:01</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> how so?
<a name="l-80"></a><span class="tm">20:25:19</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> don't follow, it's basically a new commitment type as the engine changes, no?
<a name="l-81"></a><span class="tm">20:25:33</span><span class="nk"> &lt;roasbeef&gt;</span> so you'd need something to uprgade on the fly, then start to use that
<a name="l-82"></a><span class="tm">20:25:39</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> no, you can have that and taproot, or that and Eltoo...
<a name="l-83"></a><span class="tm">20:25:46</span><span class="nk"> &lt;niftynei&gt;</span> what necesscitates a new type?
<a name="l-84"></a><span class="tm">20:25:54</span><span class="nk"> &lt;roasbeef&gt;</span> mhmm that can be another dimension/field -&gt; commitment engine or w/e
<a name="l-85"></a><span class="tm">20:26:12</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> what if I want to use the new taproot commitment, not not this new commitment engine?
<a name="l-86"></a><span class="tm">20:26:19</span><span class="nk"> &lt;niftynei&gt;</span> is eltoo a type? option_anchor_outputs?
<a name="l-87"></a><span class="tm">20:26:24</span><span class="nk"> &lt;ariard&gt;</span> and another dimension field would be dlc or any other type of packets on  top of an anchor channel
<a name="l-88"></a><span class="tm">20:26:35</span><span class="nk"> &lt;roasbeef&gt;</span> sure anything future thing really, DLC, etc, etc
<a name="l-89"></a><span class="tm">20:27:01</span><span class="nk"> &lt;roasbeef&gt;</span> on the pool side we have a new channel type that basically forks the funding commitment, so we can have a uni-directional channel that pays out coupon payments for the lease
<a name="l-90"></a><span class="tm">20:27:19</span><span class="nk"> &lt;roasbeef&gt;</span> a similar structure is useful for DLC stuff as well, before something like no_input
<a name="l-91"></a><span class="tm">20:27:58</span><span class="nk"> &lt;ariard&gt;</span> what do you mean by forking the funding commitment? a new intermediate stage
<a name="l-92"></a><span class="tm">20:28:02</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> we already have a defined feature bitmap, I think we should use it?  And define that you can only have one bit (for now).
<a name="l-93"></a><span class="tm">20:28:09</span><span class="nk"> &lt;roasbeef&gt;</span> yeh like the eltoo kick off transaction type stuff ariard
<a name="l-94"></a><span class="tm">20:28:35</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> yeh but imo I don't see how the bit map is compatible w/ explicit funding, there may be overlap, but I don't want to use that channel type as I just understand it as an example
<a name="l-95"></a><span class="tm">20:28:57</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ariard:</span> so funding output, then intermediate transaction w/ two outputs, then another level of the actual commitments
<a name="l-96"></a><span class="tm">20:29:15</span><span class="nk"> &lt;ariard&gt;</span> it's just a bitmap matrix like doesn't sound to work well with all the upcoming features
<a name="l-97"></a><span class="tm">20:29:18</span><span class="nk"> &lt;roasbeef&gt;</span> DLC rn wants something like this, as you want to be able to update the channels independently w/o invalidting the sigs w/ a txid change, w/ no_input it matters less
<a name="l-98"></a><span class="tm">20:29:31</span><span class="nk"> &lt;ariard&gt;</span> like you might be interested to use taproot output but want to apply zero-fee on the commitment once we have package relay
<a name="l-99"></a><span class="tm">20:29:35</span><span class="nk"> &lt;ariard&gt;</span> that kind of combinations
<a name="l-100"></a><span class="tm">20:30:13</span><span class="nk"> &lt;t-bast&gt;</span> I think it's dangerous to support a wide number of such combinations
<a name="l-101"></a><span class="tm">20:30:18</span><span class="nk"> &lt;roasbeef&gt;</span> yeh in my mind, you'd just flatten that all out to induvidual types
<a name="l-102"></a><span class="tm">20:30:23</span><span class="nk"> &lt;roasbeef&gt;</span> you signal if you understand it or not in feature bits
<a name="l-103"></a><span class="tm">20:30:32</span><span class="nk"> &lt;roasbeef&gt;</span> then at execution you explcitily say which one you're using
<a name="l-104"></a><span class="tm">20:31:02</span><span class="nk"> &lt;roasbeef&gt;</span> commit_sig would also start to carry that, since it'll b epossible to have two commitments of diff commit types until revoked, so you get the context during retransmission/reconstruction
<a name="l-105"></a><span class="tm">20:31:03</span><span class="nk"> &lt;niftynei&gt;</span> i'm struggling to understand the difference btw feature bits and types. it sort of sounds like you're just naming each possible feature-bit combination a 'type'?
<a name="l-106"></a><span class="tm">20:31:14</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> yea, you really want to say "I support sets A+B, A+B+C, but not A+C"
<a name="l-107"></a><span class="tm">20:31:48</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> if we send over feature bits, and have 3 channel types overlapping (we just take em from the node ann for w/e), which one are we using for the funding attempt?
<a name="l-108"></a><span class="tm">20:32:16</span><span class="nk"> &lt;niftynei&gt;</span> ok but you haven't explained what a 'channel type' is and how it's not a feature bit?
<a name="l-109"></a><span class="tm">20:32:23</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> right for DLC, idea was to group your DLC by frequency of update to avoid the really active ones bothering you update the update-once-in-a-year-contract
<a name="l-110"></a><span class="tm">20:32:36</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">BlueMatt:</span> yeah but I'd really want my implementation to avoid supporting 10 different cases, ariard's comment seemed to imply a big combinatorial explosion of possible channel configurations, and I find that dangerous (hard to properly test)
<a name="l-111"></a><span class="tm">20:32:50</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> say anchors is type 4, static key is 3, etc, etc
<a name="l-112"></a><span class="tm">20:33:08</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ariard:</span> yeh that's another option, large design space, for our specific use case it's better they be fully independent
<a name="l-113"></a><span class="tm">20:33:34</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> if there's a lot of types, you just need to know which ones you support or not, signalling happens at the feature bit level, execution one level down
<a name="l-114"></a><span class="tm">20:33:42</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> well flattening as proposed by roasbeef might work, we should aslo consider we won't deploy everything on the same dev cycle, so yuou might deprecrate old types
<a name="l-115"></a><span class="tm">20:33:49</span><span class="nk"> &lt;roasbeef&gt;</span> particularly w/ taproot, the design space really starts to expand
<a name="l-116"></a><span class="tm">20:34:03</span><span class="nk"> &lt;niftynei&gt;</span> roasbeef, i think another way to restate what you're proposing is committing to a feature-bit set at open
<a name="l-117"></a><span class="tm">20:34:06</span><span class="nk"> &lt;roasbeef&gt;</span> and the impls are getting more and more de-synchronized today
<a name="l-118"></a><span class="tm">20:34:44</span><span class="nk"> &lt;niftynei&gt;</span> which maps to your 'explicit vs implicit' designation earlier
<a name="l-119"></a><span class="tm">20:34:51</span><span class="nk"> &lt;ariard&gt;</span> yes lloyd was also working on asymmetric channnels leveraging witness scripting
<a name="l-120"></a><span class="tm">20:35:36</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ariard:</span> this variant? https://eprint.iacr.org/2020/476
<a name="l-121"></a><span class="tm">20:35:43</span><span class="nk"> &lt;ariard&gt;</span> like i would say we should only converge on a standard secure/confidential type post-taproot and let folks explore the fringers
<a name="l-122"></a><span class="tm">20:35:46</span><span class="nk"> &lt;ariard&gt;</span> *the fringes
<a name="l-123"></a><span class="tm">20:36:02</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> yep this one iirc : https://github.com/LLFourn/witness-asymmetric-channel/blob/master/original.md
<a name="l-124"></a><span class="tm">20:36:22</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> right, that was my point, like you could just support "all features up to A, B, or C, but not the combinatorial explosion of A, B, and C"
<a name="l-125"></a><span class="tm">20:36:35</span><span class="nk"> &lt;rusty&gt;</span> We may get an explosion of types, but I hope we'll generally converge on a few useful best ones.
<a name="l-126"></a><span class="tm">20:36:56</span><span class="nk"> &lt;BlueMatt&gt;</span> right, as long as you can restrict yourself to a limited set
<a name="l-127"></a><span class="tm">20:37:02</span><span class="nk"> &lt;t-bast&gt;</span> Sounds good then ;)
<a name="l-128"></a><span class="tm">20:37:03</span><span class="nk"> &lt;ariard&gt;</span> yep that's my thinking too, the few useful best ones will emerge
<a name="l-129"></a><span class="tm">20:37:04</span><span class="nk"> &lt;BlueMatt&gt;</span> an all-out explosion would be really bad.
<a name="l-130"></a><span class="tm">20:37:22</span><span class="nk"> &lt;BlueMatt&gt;</span> ie as long as we can limit ourselves to supporting only the "best sets"
<a name="l-131"></a><span class="tm">20:37:46</span><span class="nk"> &lt;roasbeef&gt;</span> imo this is related to the discussion to move away from teh current BOLT documetn structure and move forward with more contained/standalone documents
<a name="l-132"></a><span class="tm">20:38:13</span><span class="nk"> &lt;roasbeef&gt;</span> there's a lot of potential for innovation/experimentation, and I wouldn't really expect everyone to commit to keep up w/ it all, as everyone has diff priorities/needs
<a name="l-133"></a><span class="tm">20:39:00</span><span class="nk"> &lt;ariard&gt;</span> and some specification is reused by other dev communities like DLC
<a name="l-134"></a><span class="tm">20:39:01</span><span class="nk"> &lt;t-bast&gt;</span> agreed, but there are things that really need to be in the core, even for security's sake: channel commitment format is one for example
<a name="l-135"></a><span class="tm">20:39:29</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> maybe need all the scope of channel commitment formats but one dynamic upgrade mechanism seems quite core imho
<a name="l-136"></a><span class="tm">20:39:31</span><span class="nk"> &lt;t-bast&gt;</span> it's really important to have as many eyes as possible on the parts that are critical for funds safety
<a name="l-137"></a><span class="tm">20:39:34</span><span class="nk"> &lt;ariard&gt;</span> *maybe not
<a name="l-138"></a><span class="tm">20:39:42</span><span class="nk"> &lt;niftynei&gt;</span> i'm not sure what the network as a whole gains by a fractured approach to a common spec
<a name="l-139"></a><span class="tm">20:39:48</span><span class="nk"> &lt;rusty&gt;</span> I like a twist on roasbeef's idea: the open msg should enumerate all the combinations it is OK with, the accept msg picks one.
<a name="l-140"></a><span class="tm">20:40:59</span><span class="nk"> &lt;niftynei&gt;</span> (they are called 'network effects' for a reason lol)
<a name="l-141"></a><span class="tm">20:41:25</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> that's similar to the closing change we've done recently: the node initiating close specifies the fees it's ok with, and the other node chooses one in that range
<a name="l-142"></a><span class="tm">20:41:47</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> in the end, the network in a sense is the shared HTLC construct
<a name="l-143"></a><span class="tm">20:41:50</span><span class="nk"> &lt;t-bast&gt;</span> (https://github.com/lightningnetwork/lightning-rfc/pull/847)
<a name="l-144"></a><span class="tm">20:41:58</span><span class="nk"> &lt;roasbeef&gt;</span> as long as that's the asme along a route, doesn't really matter what transfers it
<a name="l-145"></a><span class="tm">20:42:10</span><span class="nk"> &lt;niftynei&gt;</span> <span class="hi">t-bast:</span> that's still on my to-do list, btw!
<a name="l-146"></a><span class="tm">20:42:12</span><span class="nk"> &lt;roasbeef&gt;</span> or ptlc or w/e the kid are calling it these days
<a name="l-147"></a><span class="tm">20:42:16</span><span class="nk"> &lt;t-bast&gt;</span> but it does matter for the network as a list if it's unsecure!
<a name="l-148"></a><span class="tm">20:42:24</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> htlc-over-opendime?
<a name="l-149"></a><span class="tm">20:43:03</span><span class="nk"> &lt;t-bast&gt;</span> let's not forget that ariard found an issue with anchor even after it had been reviewed a lot, so imagine what happens when new channel commitment types are deployed without getting as much review?
<a name="l-150"></a><span class="tm">20:43:20</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> i like this twist too, you guarantee to do the negotiation in one RTT
<a name="l-151"></a><span class="tm">20:43:34</span><span class="nk"> &lt;niftynei&gt;</span> in a sense, sure. in practical reality it's confusing to end-users if nodes dont interoperate as expected lol
<a name="l-152"></a><span class="tm">20:43:47</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> tradeoffs in the end, do you think you'd be able to keep up w/ and fully review everything that came across the board?
<a name="l-153"></a><span class="tm">20:44:04</span><span class="nk"> &lt;roasbeef&gt;</span> from my pov feels like we've kinda reeached that point already
<a name="l-154"></a><span class="tm">20:44:05</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> no, but I think it's a good thing that it moves slowly
<a name="l-155"></a><span class="tm">20:44:10</span><span class="nk"> &lt;BlueMatt&gt;</span> what t-bast said. There's massive usability loss from fragmentation. its one thing to have certain major systems (like DLC) separate, but something else to have things like keysend or 0-value invoices be fragmented. those we've seen actively hurt users many times.
<a name="l-156"></a><span class="tm">20:44:23</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> frustrating sometimes, but better in the long run imho
<a name="l-157"></a><span class="tm">20:44:49</span><span class="nk"> &lt;ariard&gt;</span> but maybe we should have differing tracks inside the same LN specification effort
<a name="l-158"></a><span class="tm">20:44:59</span><span class="nk"> &lt;roasbeef&gt;</span> nimbleness of LN as is is a strength imo, like rn a buncha wallets do custom things that improve their UX, they just did it and didn't need to "ask permission" from anyone as they were driving towards a precise goal
<a name="l-159"></a><span class="tm">20:45:05</span><span class="nk"> &lt;ariard&gt;</span> the ietf is doing it for a bunch of protocols like sip
<a name="l-160"></a><span class="tm">20:45:15</span><span class="nk"> &lt;cdecker&gt;</span> Agreed, experimentation is all good and fine, but we need a minimal common set that ensures compatibility and a good UX
<a name="l-161"></a><span class="tm">20:45:17</span><span class="nk"> &lt;rusty&gt;</span> I sympathize with roasbeef here: more freedom to experiment is good, as long as it's explicit in the protocol.
<a name="l-162"></a><span class="tm">20:45:21</span><span class="nk"> &lt;roasbeef&gt;</span> ideally taht custom stuff is at least _documented_, wouldn't expect everyone to impl all of it tho
<a name="l-163"></a><span class="tm">20:46:06</span><span class="nk"> &lt;t-bast&gt;</span> of course there are parts of the protocol that are prone to quicker prototyping and deployment, but for the really core parts I think it's important to move slow and get everyone to look at it - but I'm not sure where to put the boundary of what is "core"
<a name="l-164"></a><span class="tm">20:46:08</span><span class="nk"> &lt;BlueMatt&gt;</span> right, my issue is more "going off in one direction without even documenting it". I think we all agree experimentation is good, as long as those things make their way into the spec eventually and we can learn from the experiementation and get broader review.
<a name="l-165"></a><span class="tm">20:46:19</span><span class="nk"> &lt;ariard&gt;</span> i agree on proning the experimentation aspect, as long as we can find a proper documentation somewhere
<a name="l-166"></a><span class="tm">20:46:49</span><span class="nk"> &lt;roasbeef&gt;</span> another example is something like ln-url: pretty much all the major wallets implement it, but the spec itself is pretty light and isolated from everything else
<a name="l-167"></a><span class="tm">20:47:20</span><span class="nk"> &lt;roasbeef&gt;</span> some of us may not really like the tradeoffs it makes, but wallets use it as it solves a problem for them
<a name="l-168"></a><span class="tm">20:47:26</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> good example, this is the kind of thing that would make sense to have in a BIP-like document close to the spec
<a name="l-169"></a><span class="tm">20:47:27</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> +1
<a name="l-170"></a><span class="tm">20:47:50</span><span class="nk"> &lt;niftynei&gt;</span> ln-url doesn't deal with inter-node communication
<a name="l-171"></a><span class="tm">20:47:58</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> yeh def, in terms of like "tracks" agree there's like a fundamental track (htlc types, etc) then would be others
<a name="l-172"></a><span class="tm">20:48:13</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> it kinda does, ppl use it to communicate invoices between nodes
<a name="l-173"></a><span class="tm">20:48:19</span><span class="nk"> &lt;BlueMatt&gt;</span> ln-url is great, I also love that it has documentation and such. would be great if it were *in* the bolts repo, maybe under an experiemtntal/ directory
<a name="l-174"></a><span class="tm">20:48:21</span><span class="nk"> &lt;roasbeef&gt;</span> for like scan to withdraw flows, etc
<a name="l-175"></a><span class="tm">20:48:28</span><span class="nk"> &lt;ariard&gt;</span> yep we should have more tracks if people feel like it, bip do have consensus/p2p/applications/etc
<a name="l-176"></a><span class="tm">20:48:49</span><span class="nk"> &lt;roasbeef&gt;</span> fwiw offers kinda occupies the same domain as it tho, as they offer similar functionality in the end
<a name="l-177"></a><span class="tm">20:48:50</span><span class="nk"> &lt;BlueMatt&gt;</span> this may be somewhere we can learn from BIPs - they exist only to communicate things people wish to be interoperable, not to "get review", we could have an experimental/ folder for similar documents
<a name="l-178"></a><span class="tm">20:48:55</span><span class="nk"> &lt;rusty&gt;</span> Well, offers covers much of this (though not all!).
<a name="l-179"></a><span class="tm">20:49:11</span><span class="nk"> &lt;BlueMatt&gt;</span> those things dont have to go into the main bolts, but they could be a "for now we're doign this, we may do something else later"
<a name="l-180"></a><span class="tm">20:49:21</span><span class="nk"> &lt;ariard&gt;</span> and another aspect to consider is documenting "best practices" especially how you taught node operators to select config parameters in function of use-case
<a name="l-181"></a><span class="tm">20:50:21</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">BlueMatt:</span> +1 for the "experimental" or "proposals" folder, what would be the criteria to get it merged though? What review does it need?
<a name="l-182"></a><span class="tm">20:50:32</span><span class="nk"> &lt;roasbeef&gt;</span> I g2g in 10
<a name="l-183"></a><span class="tm">20:50:33</span><span class="nk"> &lt;BlueMatt&gt;</span> I'd assume none
<a name="l-184"></a><span class="tm">20:50:50</span><span class="nk"> &lt;BlueMatt&gt;</span> like there should be *opportunity* for review, but it could be, like BIPs, "author documents"
<a name="l-185"></a><span class="tm">20:50:50</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> i would say a minimal bar of not being junk and decently written, like only 1 implem supporting it?
<a name="l-186"></a><span class="tm">20:51:01</span><span class="nk"> &lt;BlueMatt&gt;</span> like, the author decides what the contents are, and others can only provide feedback
<a name="l-187"></a><span class="tm">20:51:04</span><span class="nk"> &lt;t-bast&gt;</span> Ok, interesting
<a name="l-188"></a><span class="tm">20:51:11</span><span class="nk"> &lt;rusty&gt;</span> Anyway, thanks for the discussion, esp roasbeef.  I am going to go back and change the upgrade proposal to explicitly list a set of allowable upgrades rather than a single bitfield (which has awkward semantics as diff possibilities arise).
<a name="l-189"></a><span class="tm">20:51:24</span><span class="nk"> &lt;t-bast&gt;</span> And the stronger review would happen when we'd want to move it from "experimental/proposal" to a core BOLT?
<a name="l-190"></a><span class="tm">20:51:34</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> pushes me actually write down my ideas too lol
<a name="l-191"></a><span class="tm">20:51:41</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> in practice review happen when you implement the stuff
<a name="l-192"></a><span class="tm">20:51:43</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> :)
<a name="l-193"></a><span class="tm">20:51:52</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> yes
<a name="l-194"></a><span class="tm">20:52:06</span><span class="nk"> &lt;roasbeef&gt;</span> I think splitting thngs out would also make the spec a lot easier to read, idk about y'all but I find it hard parsing thru it rn, as there's basically a buncha if statements everywhere
<a name="l-195"></a><span class="tm">20:52:06</span><span class="nk"> &lt;BlueMatt&gt;</span> rusty and roasbeef: thanks y'all!
<a name="l-196"></a><span class="tm">20:52:13</span><span class="nk"> &lt;roasbeef&gt;</span> especially when reviewing diffs
<a name="l-197"></a><span class="tm">20:52:22</span><span class="nk"> &lt;t-bast&gt;</span> roasbeef:iIt would be great to have two proposals to look at to see the differences!
<a name="l-198"></a><span class="tm">20:52:26</span><span class="nk"> &lt;BlueMatt&gt;</span> yea, I tend to agree, though its good to have a "core thing"
<a name="l-199"></a><span class="tm">20:52:27</span><span class="nk"> &lt;roasbeef&gt;</span> also not clear to new ppl how things have evolved over time either, other than looking at the git history ofc
<a name="l-200"></a><span class="tm">20:52:30</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> Grand Feature Elimination is on my TODO, TBH.
<a name="l-201"></a><span class="tm">20:52:42</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> yeah made the point about interactive construction protocol could be its own BIP
<a name="l-202"></a><span class="tm">20:53:00</span><span class="nk"> &lt;ariard&gt;</span> *BOLT
<a name="l-203"></a><span class="tm">20:53:05</span><span class="nk"> &lt;rusty&gt;</span> (After we have upgradality ofc)
<a name="l-204"></a><span class="tm">20:53:10</span><span class="nk"> &lt;rusty&gt;</span> *upgradability
<a name="l-205"></a><span class="tm">20:53:17</span><span class="nk"> &lt;ariard&gt;</span> okay let's move on from upgradability?
<a name="l-206"></a><span class="tm">20:53:24</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> please :)
<a name="l-207"></a><span class="tm">20:53:30</span><span class="nk"> &lt;ariard&gt;</span> do we have another long-term subject we want to parse?
<a name="l-208"></a><span class="tm">20:53:35</span><span class="nk"> &lt;t-bast&gt;</span> let's call these "sparks" instead of lightning BIPs
<a name="l-209"></a><span class="tm">20:53:36</span><span class="nk"> &lt;ariard&gt;</span> like dual-funding?
<a name="l-210"></a><span class="tm">20:53:57</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> tonnere, foudre, orage?
<a name="l-211"></a><span class="tm">20:54:05</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> oh, dual-funding, splicing and splice-to-close are all related, BTW.
<a name="l-212"></a><span class="tm">20:54:16</span><span class="nk"> &lt;ariard&gt;</span> <span class="topic">#topic </span><span class="topicline">dual-funding &amp; friends</span>
<a name="l-213"></a><span class="tm">20:54:30</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">ariard:</span> Ã©tincelle, for the experimental proposals!
<a name="l-214"></a><span class="tm">20:55:10</span><span class="nk"> &lt;ariard&gt;</span> wr.t to dual-funding or any others multi-party funded protocols like splicing
<a name="l-215"></a><span class="tm">20:55:16</span><span class="nk"> &lt;rusty&gt;</span> Not sure if I should leave this to niftynei...
<a name="l-216"></a><span class="tm">20:55:31</span><span class="nk"> &lt;niftynei&gt;</span> i'm not sure what kind of discussion we're looking for haha
<a name="l-217"></a><span class="tm">20:55:37</span><span class="nk"> &lt;niftynei&gt;</span> so go ahead rusty?
<a name="l-218"></a><span class="tm">20:55:55</span><span class="nk"> &lt;rusty&gt;</span> Err, OK.  I'm two coffees down, so good to go I guess :)
<a name="l-219"></a><span class="tm">20:55:56</span><span class="nk"> &lt;ariard&gt;</span> we're quite vulnerable to a bunch of dumb DoSes as documented here : https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html
<a name="l-220"></a><span class="tm">20:56:54</span><span class="nk"> &lt;ariard&gt;</span> so rn, opening a multi-party funded channel require more trust in your counterparty
<a name="l-221"></a><span class="tm">20:57:07</span><span class="nk"> &lt;ariard&gt;</span> than single-funded one, and i'm not if it's rightly captured by the spec
<a name="l-222"></a><span class="tm">20:57:37</span><span class="nk"> &lt;rusty&gt;</span> So, the basic protocol of DF uses a negotiation method, which took more than a year to refine because we wanted to reuse it for everything else, and we wanted it to be usable by either peer to coordinate with multiple peers at once.
<a name="l-223"></a><span class="tm">20:57:50</span><span class="nk"> &lt;ariard&gt;</span> and beyond adverserial settings, we have also lazzy/buggy peers, where you might want to fallback and funding timeout recovery style of things
<a name="l-224"></a><span class="tm">20:58:19</span><span class="nk"> &lt;rusty&gt;</span> The good news is, it works for splice, and a to-be-defined subset of splice which is splice-to-close.
<a name="l-225"></a><span class="tm">20:59:02</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">Implementation-wise:</span> niftynei has reckless experimental option which has been used on mainnet for DF (though I don't think they had to RBF?), and I'm actively working on splice.  Splice is easier to define if quiescent, hence my work there.
<a name="l-226"></a><span class="tm">20:59:27</span><span class="nk"> &lt;rusty&gt;</span> (Close is naturally quiescent since we define it to start once all updates are done).
<a name="l-227"></a><span class="tm">21:00:49</span><span class="nk"> &lt;niftynei&gt;</span> rusty, correct the DF open worked as expected the first time lol
<a name="l-228"></a><span class="tm">21:00:51</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> what flavor of splice-in it's about? you parallelize channel updates until new funding_txo has enough confirmation?
<a name="l-229"></a><span class="tm">21:00:54</span><span class="nk"> &lt;niftynei&gt;</span> ariard, by DOS you mean "channel doesn't open (in a reasonable timeframe)"
<a name="l-230"></a><span class="tm">21:01:31</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> yeap funding doesn't confirm in a reasonable timeframe, what should you do?
<a name="l-231"></a><span class="tm">21:01:33</span><span class="nk"> &lt;t-bast&gt;</span> for splice, do you stay quiescent until you have on-chain confirmations?
<a name="l-232"></a><span class="tm">21:01:41</span><span class="nk"> &lt;niftynei&gt;</span> which is .. currently the case with channel opens because of feerates etc. in theory we get around that by double-spending the inputs after a timeout
<a name="l-233"></a><span class="tm">21:01:56</span><span class="nk"> &lt;niftynei&gt;</span> :s/in theory//
<a name="l-234"></a><span class="tm">21:01:58</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> yes, exactly.  Technically there's no splice in vs out distinction then.  Splice proposer pays for 1 input (spending channel), 1 output (new channel out) and the tx core. Other side can choose to add whatever they want.
<a name="l-235"></a><span class="tm">21:02:14</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> naah, just during active negotiation.
<a name="l-236"></a><span class="tm">21:02:23</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> i.e. tx construction.
<a name="l-237"></a><span class="tm">21:02:31</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> it sounds good in non-adverserial settings, in non-adverserial settings you should beware upper bounding your fee-bumping
<a name="l-238"></a><span class="tm">21:02:37</span><span class="nk"> &lt;ariard&gt;</span> *adverserial settings
<a name="l-239"></a><span class="tm">21:02:38</span><span class="nk"> &lt;t-bast&gt;</span> how does that work if that tx never confirms?
<a name="l-240"></a><span class="tm">21:02:58</span><span class="nk"> &lt;t-bast&gt;</span> you *have* to make it confirm through CPFP whatever the cost?
<a name="l-241"></a><span class="tm">21:03:15</span><span class="nk"> &lt;niftynei&gt;</span> right now you have to CPFP a channel open if it doesn't confirm
<a name="l-242"></a><span class="tm">21:03:19</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> you carry those forever, and you can have multiple; only constraint is that they must pay 1.25x feerate of previous.
<a name="l-243"></a><span class="tm">21:03:36</span><span class="nk"> &lt;niftynei&gt;</span> the DF protocol provides a method for initiating an RBF with your peer
<a name="l-244"></a><span class="tm">21:04:06</span><span class="nk"> &lt;t-bast&gt;</span> ok, it's a chain so you only move forward? Does it mean you could have two unconfirmed splices going (the second one applied after the first one)?
<a name="l-245"></a><span class="tm">21:04:32</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> no, they are all in parallel.  You can't start a second on top of the first.
<a name="l-246"></a><span class="tm">21:04:46</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> (we had to stop somewhere!)
<a name="l-247"></a><span class="tm">21:05:26</span><span class="nk"> &lt;t-bast&gt;</span> Ok, I must be missing on the fundamentals of splicing then...doesn't splicing just spend the funding tx to make a new funding tx for the channel?
<a name="l-248"></a><span class="tm">21:05:52</span><span class="nk"> &lt;t-bast&gt;</span> Like a close and an open merged in one tx (with the opportunity to dual-fund added)?
<a name="l-249"></a><span class="tm">21:06:10</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> yes, but also adds arbitrary outputs and inputs.  You can propose *another* splice, but it must be at 1.25x (or more) of previous splice feerate.
<a name="l-250"></a><span class="tm">21:06:30</span><span class="nk"> &lt;t-bast&gt;</span> oh ok so this other splice would replace the previous one entirely?
<a name="l-251"></a><span class="tm">21:06:41</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> we carry all the possible splices until one wins 6 confs.
<a name="l-252"></a><span class="tm">21:06:50</span><span class="nk"> &lt;rusty&gt;</span> Then we clear them all, and you can propose a new one.
<a name="l-253"></a><span class="tm">21:06:53</span><span class="nk"> &lt;t-bast&gt;</span> Ok, that's clear now
<a name="l-254"></a><span class="tm">21:06:55</span><span class="nk"> &lt;t-bast&gt;</span> Thanks
<a name="l-255"></a><span class="tm">21:07:49</span><span class="nk"> &lt;rusty&gt;</span> If you propose a giant feerate, that's fine, but your peer is unlikely to contribute any changes.  You can ofc make an invalid input and block further splices, but you can always make a channel useless in less exotic ways, too.
<a name="l-256"></a><span class="tm">21:07:55</span><span class="nk"> &lt;t-bast&gt;</span> Interesting, I can see the synergy with interactive-tx then
<a name="l-257"></a><span class="tm">21:07:56</span><span class="nk"> &lt;ariard&gt;</span> you should beware of respecting the absolute fee for RBF, otherwise you lastest splice might not propagae
<a name="l-258"></a><span class="tm">21:08:14</span><span class="nk"> &lt;ariard&gt;</span> though do you really care as long as you expect *any* one of them to confirm?
<a name="l-259"></a><span class="tm">21:08:20</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> exactly.
<a name="l-260"></a><span class="tm">21:08:35</span><span class="nk"> &lt;niftynei&gt;</span> yeah, it's possible you make a non-propagating tx but then you'd just try again?
<a name="l-261"></a><span class="tm">21:08:38</span><span class="nk"> &lt;rusty&gt;</span> (Though you're right, proposer should check this!)
<a name="l-262"></a><span class="tm">21:09:05</span><span class="nk"> &lt;rusty&gt;</span> But this is why it kind of goes with splice-to-close, since you can't currently shutdown with outstanding splices.
<a name="l-263"></a><span class="tm">21:09:09</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> nightmare scenario where a reorg occurs, and a parent gets unconfirmed violating bip125 rule 4?
<a name="l-264"></a><span class="tm">21:09:37</span><span class="nk"> &lt;niftynei&gt;</span> how big of a reorg are you talking?
<a name="l-265"></a><span class="tm">21:09:38</span><span class="nk"> &lt;ariard&gt;</span> *rule 2 : don't add new unconf input
<a name="l-266"></a><span class="tm">21:10:14</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> even 1-depth reorg is enough to make your transaction not propagating? as a rule of thumb maybe recommend to use parent well-confirmed?
<a name="l-267"></a><span class="tm">21:11:30</span><span class="nk"> &lt;niftynei&gt;</span> what makes this a nightmare scenario ariard?
<a name="l-268"></a><span class="tm">21:11:52</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> yeah, but you can keep sending it to bitcoind and it eventually works once tx is remined.  Unless you're double-spending, which is always possible?
<a name="l-269"></a><span class="tm">21:12:33</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> parent might get double-spent, and you have to adapt your tx construction ?
<a name="l-270"></a><span class="tm">21:13:05</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> yeah, that'd cost you 25% bump in fees, but is possible?
<a name="l-271"></a><span class="tm">21:13:07</span><span class="nk"> &lt;niftynei&gt;</span> iiuc for channel opens, you'd have to RBF the tx *again*. you don't lose anything but time
<a name="l-272"></a><span class="tm">21:13:24</span><span class="nk"> &lt;niftynei&gt;</span> oh right and the fee bump rate
<a name="l-273"></a><span class="tm">21:13:56</span><span class="nk"> &lt;rusty&gt;</span> Maybe 25% is too harsh, but as ariard says, if you're using low-confirmed txs you're playing with matches already maybe?
<a name="l-274"></a><span class="tm">21:13:58</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> depends if you have a double-spend in network mempools not signaling rbf, RBF on your side is pretty useless
<a name="l-275"></a><span class="tm">21:14:16</span><span class="nk"> &lt;niftynei&gt;</span> this could happen with a normal channel open today also, no?
<a name="l-276"></a><span class="tm">21:14:47</span><span class="nk"> &lt;niftynei&gt;</span> ah wait, no it's a RBF only corner case and you can't rbf an open today. ok
<a name="l-277"></a><span class="tm">21:15:11</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> with a normal channel open, the funder will either double-spend or RBF
<a name="l-278"></a><span class="tm">21:15:29</span><span class="nk"> &lt;niftynei&gt;</span> you cant RBF an open right now, you'd have to CPFP it
<a name="l-279"></a><span class="tm">21:15:41</span><span class="nk"> &lt;ariard&gt;</span> with dual-funding or N-funding, each counterparty might have a rebroadcast/differing policy failure
<a name="l-280"></a><span class="tm">21:16:21</span><span class="nk"> &lt;ariard&gt;</span> like Alice is trying to RBF, but Bob already reaches his funding timer and double-spend his contributed inputs
<a name="l-281"></a><span class="tm">21:16:30</span><span class="nk"> &lt;niftynei&gt;</span> the mitigation for these corner cases is the same though, no? you double spend an input.
<a name="l-282"></a><span class="tm">21:16:51</span><span class="nk"> &lt;niftynei&gt;</span> ok so at some point Alice will also hit her funding timer and double-spend her input
<a name="l-283"></a><span class="tm">21:17:12</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> that's a nice failure if both counterparties double-spend their inputs at the same time
<a name="l-284"></a><span class="tm">21:17:41</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> really messy cases it's when your counterparty pin the funding transaction to block your double-spend propagation on the network
<a name="l-285"></a><span class="tm">21:17:45</span><span class="nk"> &lt;niftynei&gt;</span> does 'at the same time' matter? eventually they should both end up in the same state
<a name="l-286"></a><span class="tm">21:17:50</span><span class="nk"> &lt;niftynei&gt;</span> true, that does sound messy
<a name="l-287"></a><span class="tm">21:18:05</span><span class="nk"> &lt;ariard&gt;</span> anyway, i think we'll improve those cooernes cases over time, the core interaction protocol sounds good enough for me :)
<a name="l-288"></a><span class="tm">21:18:10</span><span class="nk"> &lt;niftynei&gt;</span> any time someone blocks a tx propagation it gets messy haha
<a name="l-289"></a><span class="tm">21:18:36</span><span class="nk"> &lt;ariard&gt;</span> Package Relay Solves This (or maybe Eltoo?)
<a name="l-290"></a><span class="tm">21:18:48</span><span class="nk"> &lt;niftynei&gt;</span> PRST !!
<a name="l-291"></a><span class="tm">21:18:49</span><span class="nk"> &lt;niftynei&gt;</span> haha
<a name="l-292"></a><span class="tm">21:19:08</span><span class="nk"> &lt;ariard&gt;</span> any other topic or we shutdown here?
<a name="l-293"></a><span class="tm">21:19:09</span><span class="nk"> &lt;niftynei&gt;</span> cool, thanks for lending your pinning + feerate expertise to the review!
<a name="l-294"></a><span class="tm">21:19:30</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> yw, feel free to ask further questions on the pr :)
<a name="l-295"></a><span class="tm">21:19:43</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> I think we're overtime, but good conversation!@
<a name="l-296"></a><span class="tm">21:20:00</span><span class="nk"> &lt;ariard&gt;</span> yep was a good one
<a name="l-297"></a><span class="tm">21:20:02</span><span class="nk"> &lt;ariard&gt;</span> <span class="cmd">#endmeeting</span><span class="cmdline"></span></pre>
</body></html>
